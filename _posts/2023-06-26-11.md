---
layout: single
title: "11) Fast API ( 수정 진행 중 ) "
categories: python
tag: Web FrameWork
toc: true
toc_sticky: true
toc_label: 목차
toc_icon: "fas fa-dragon"
author_profile: false
sidebar:
    nav: "counts"

---

# FastAPI, uvicorn 학습.

## 1. FastAPI란 ?

> FastAPI는 현대적이고, 빠르며, 파이썬 표준 타입 힌트에 기초한 Python3.6+의 API를 빌드하기 위한 웹 프레임 워크입니다.

- 빠르다. NodeJS 및 Go와 대등할 정도로 매우 높은 성능.

[FastAPI 공식 문서]([FastAPI (tiangolo.com)](https://fastapi.tiangolo.com/ko/))

- 웹 프레임워크 : Spring Framework, Django, Flask, Sanic etc.

- 마이크로 프레임워크 : Flask, Sanic ( http 응답 )

- ASGI 애플리케이션
  
  - WSGI ( Web Server Gateway Interface )
  
  - WSGI 와 차이점 : 비동기를 지원.

### 1.1 왜 Fastapi를 써야 하는가?

- 배우기 쉽다.

- 모던 파이썬 문법
  
  - 비동기 키워드 : async, await
  
  - 타입 힌트

- OpenAPI 기반 ( + GraphQL )
  
  - Restful API를 지원하기 위한 일종의 스펙

- 자동 문서 생성

- 마이크로 프레임 워크
  
  - API 서버
  
  - MSA

> 마이크로 프레임 워크를 왜 사용해야 하는 것일까?
> 
> 하나의 거대한 앱에 모든 기능이 다 들어가는 것이 주류였는데, 이 경우 서비스 하나가 죽으면 서버가 다운되는 경우가 발생한다. 작은 서비스 하나하나로 쪼개서 하나의 서비스를 이루는 것이 중요하다.
> 
> EX) 로그인 따로, 장바구니 따로, 프로필 조회 따로.
> 
> 다른 서비스가 죽어도 다른 서비스 같이 죽으면 안된다.



### 1.2 VS Flask

```Flask
from flask import Flask

app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello, World!"
```



```FaskAPI
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def hello():
    return "Hello, World!"
```



- FastAPI는 자체적으로 Restful api 사용을 유도하기 때문에 Flask 와 차이점이 존재한다



## 2. FastAPI 설치 및 Pydantic 소개



### 2.1 파이썬 버전 확인하기

- FastAPI는 모던 파이썬(3.6+)만을 지원하므로 3.6 이상의 파이썬이 반드시 설치되어 있어야 한다.

- 파이썬 버전은 다음 명령어로 확인할 수 있다.

```
python3 -V
python3 --version
```



        

## 3. uvicorn이란?

> Uvicorn is a lightning-fast ASGI server implementation, using uvloop and httptools.

- ASGI ( Asynchronous Server Gateway Interface ) 비동기식 서비스 게이트웨이 인터페이스

- 비동기 가능 Python 웹 서비스 프레임워크와 애플리케이션 사이에서 표준 인터페이스를 제공하기 위한 것입니다.

## 4. 가상환경 설정하기

[가상환경 설정]([개발과 일상 (tistory.com)](https://ksr930.tistory.com/306))

[가상환경 패키지 관리]([파이썬 가상환경 venv 사용하기 (패키지 쉽게 관리하기) - 아무튼 워라밸 (hleecaster.com)](https://hleecaster.com/python-venv/))

> 매번 할때마다 설정 해 주는 것이 좋다. 환경 설정 겹치는 것 방지하기 위해서.

1. 가상환경을 만들고자 하는 폴더로 이동한다
   
   - cd (폴더이름)

2. python -m venv venv_fastAPI 입력

3. <가상환경이름>\Scripts\activate 입력
   
   - 가상환경 활성화

> 가상환경을 비활성화 하려면 deactivate 라고 치면 된다.

## 5. 라이브러리 설치하기.

- pip install fastapi "uvicorn[standard]"

- pip install --upgrade pip

- touch main.py (리눅스) 
  
  - fsutil file createnew main.py(파일이름.확장자) 0(사이즈)

- pip freeze - 설치된 패키지 목록

- pip freeze > requirements.txt - 프로젝트 폴더 안에 txt파일이 생성되며 가상환경 목록이 작성됨. 
  
  > 나중에 다른 가상환경에 이 목록을 똑같이 설치하거나 삭제할 때 유용하다.
  > 
  > 만약 다른 가상환경에 이 패키지들을 한 방에 설치하려면 이 텍스트 파일을 새로운 프로젝트 폴더 안에 가져와서 pip install -r requirments.txt 라고 써주면 된다. 내가 사용했던 가상환경, 그 안에 설치된 패키지들을 한 방에 삭제하고 싶다면 그냥 과감히 venv로 생성한 가상환경 이름의 폴더를 휴지통으로 보내면 끝이다. ( 가상환경을 삭제 하는 별도의 명령어는 없다. )

- 에디터 사용 할 시 터미널 확인 필수. 

### 5-1. 밑줄로 인식을 못할 경우

![]({{site.url}}/images/2023-06-26-11/2023-06-26-14-46-49-image.png)

- python path 를 잡아주어야 한다.

- Ctrl + Shift + P -> Python select interpretor

- Find -> 해당 가상환경 파일 경로 python.exe 

## 6. 코드 작성 하기.

### 6-1. 실행 코드 예제

```main.py
from typing import Union

from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}
```

```
uvicorn main:app --reload
```

> uvicorn은 설치한 라이브러리(웹 서비스)이고,
> 
> main은 main.py의 이름,
> 
> app은 main.py에서 인스턴스 
> 
> ex) app = FastAPI()
> 
> --reload는 코드 내 변동사항이 생길 때마다
> 
> 다시업로드한다는 의미이다.
> 
> localhost:8000/items/19

![]({{site.url}}/images/2023-06-26-11/2023-06-26-14-31-52-image.png)

> localhost:8000/items/19?q=world

![]({{site.url}}/images/2023-06-26-11/2023-06-26-14-33-22-image.png)

> localhost:8000/docs

![]({{site.url}}/images/2023-06-26-11/2023-06-26-14-34-21-image.png)

> localhost:8000/redoc

![]({{site.url}}/images/2023-06-26-11/2023-06-26-14-36-18-image.png)

```from
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel


app = FastAPI()

class Item(BaseModel):
    name: str
    price: float
    is_offer: Union[bool, None] = None


@app.get("/")
def read_root():
    return {"Hello": "World"}

@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}

@app.put("/items/{itme_id}")
def update_item(item_id: int, item: Item):
    return {"item_name" : item.name, "item_id": item_id}
```

- 실행결과
  
  ![]({{site.url}}/images/2023-06-26-11/2023-06-26-14-46-19-image.png)

## 7. JSON을 더 깔끔하게 보여주는 Chrome Extension

![]({{site.url}}/images/2023-06-26-11/2023-06-26-15-19-08-image.png)

## 8. HTTP request methods

HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as HTTP verbs. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be safe, idempotent, or cacheable.

### 8.1 GET

The GET method requests a representation of the specified sesource. Requests using GET should only retrieve data.

### 8.2 HEAD

The HEAD method asks for a response identical to a GET request, but without the response body.

### 8.3 POST

The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server.

### 7.4 PUT

THE PUT method replaces all current representations of the target resource with the request payload.

> 백엔드 데이터 업데이트

### 7.5 DELETE

The DELETE method deletes the specified resource.

### 7.6 CONNECT

The CONNECT method establish a tunnel to the server identified by the target resource.

### 7.7 OPTIONS

THE OPTIONS method describes the communication options for the target resource.

### 7.8 TRACE

The TRACE method performs a message loop-back test along the path to the target resource.

### 7.9 PATCH

THE PATCH method applies partial modifications to a resource.
